/// <reference path="HeartbeatService.d.ts" />
//
// Autogenerated by Thrift Compiler (0.14.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');
import shared_ttypes = require('./shared_types');


import ttypes = require('./projectmanager_types');
import ToolType = ttypes.ToolType
import InvocationType = ttypes.InvocationType
import NodeType = ttypes.NodeType
import PROJECTMANAGER_ID = ttypes.PROJECTMANAGER_ID
import ProjectManagerError = ttypes.ProjectManagerError
import ToolDefinition = ttypes.ToolDefinition
import Toolchain = ttypes.Toolchain
import Configuration = ttypes.Configuration
import ProjectContext = ttypes.ProjectContext
import Node = ttypes.Node
import HeartbeatService = require('./HeartbeatService');

declare class Client extends HeartbeatService.Client {
  #output: thrift.TTransport;
  #pClass: thrift.TProtocol;
  #_seqid: number;

  constructor(output: thrift.TTransport, pClass: { new(trans: thrift.TTransport): thrift.TProtocol });

  /**
   * Create new, empty project with the provided file path
   */
  CreateEwpFile(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Create new, empty project with the provided file path
   */
  CreateEwpFile(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Load project from .ewp file
   */
  LoadEwpFile(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Load project from .ewp file
   */
  LoadEwpFile(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Save project to file specified in the context
   */
  SaveEwpFile(project: ProjectContext): Q.Promise<void>;

  /**
   * Save project to file specified in the context
   */
  SaveEwpFile(project: ProjectContext, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Get existing project context given file path
   */
  GetProject(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Get existing project context given file path
   */
  GetProject(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Close loaded project, freeing the resources allocated for it by the project manager
   */
  CloseProject(project: ProjectContext): Q.Promise<void>;

  /**
   * Close loaded project, freeing the resources allocated for it by the project manager
   */
  CloseProject(project: ProjectContext, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Add a Configuration to a project
   */
  AddConfiguration(config: Configuration, project: ProjectContext, isDebug: boolean): Q.Promise<void>;

  /**
   * Add a Configuration to a project
   */
  AddConfiguration(config: Configuration, project: ProjectContext, isDebug: boolean, callback?: (error: void, response: void)=>void): void;

  /**
   * Remove a Configuration from a project given its name
   */
  RemoveConfiguration(configurationName: string, project: ProjectContext): Q.Promise<void>;

  /**
   * Remove a Configuration from a project given its name
   */
  RemoveConfiguration(configurationName: string, project: ProjectContext, callback?: (error: void, response: void)=>void): void;

  /**
   * Get all Configurations in a project
   */
  GetConfigurations(project: ProjectContext): Q.Promise<Configuration[]>;

  /**
   * Get all Configurations in a project
   */
  GetConfigurations(project: ProjectContext, callback?: (error: void, response: Configuration[])=>void): void;

  /**
   * Get the root of a project's file and group hierarchy tree, including all children
   */
  GetRootNode(ctx: ProjectContext): Q.Promise<Node>;

  /**
   * Get the root of a project's file and group hierarchy tree, including all children
   */
  GetRootNode(ctx: ProjectContext, callback?: (error: void, response: Node)=>void): void;

  /**
   * Set a node in the project's hierarchy, possibly replacing an existing subtree if a node with the same name already exists (e.g. the project root).
   */
  SetNode(ctx: ProjectContext, node: Node): Q.Promise<void>;

  /**
   * Set a node in the project's hierarchy, possibly replacing an existing subtree if a node with the same name already exists (e.g. the project root).
   */
  SetNode(ctx: ProjectContext, node: Node, callback?: (error: void, response: void)=>void): void;

  /**
   * Get a list of available Toolchains.
   */
  GetToolchains(): Q.Promise<Toolchain[]>;

  /**
   * Get a list of available Toolchains.
   */
  GetToolchains(callback?: (error: ttypes.ProjectManagerError, response: Toolchain[])=>void): void;

  /**
   * Register a toolchain with the project manager. Will fail if the toolchain is already registered.
   */
  AddToolchain(toolchain: Toolchain): Q.Promise<void>;

  /**
   * Register a toolchain with the project manager. Will fail if the toolchain is already registered.
   */
  AddToolchain(toolchain: Toolchain, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Build a project configuration asynchronously. Will notify the build result when done as an event.
   */
  BuildProject(prj: ProjectContext, configurationName: string): Q.Promise<void>;

  /**
   * Build a project configuration asynchronously. Will notify the build result when done as an event.
   */
  BuildProject(prj: ProjectContext, configurationName: string, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;
}

declare class Processor extends HeartbeatService.Processor {
  #_handler: object;

  constructor(handler: object);
  process(input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_CreateEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_LoadEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_SaveEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_CloseProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_AddConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_RemoveConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetConfigurations(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetRootNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_SetNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetToolchains(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_AddToolchain(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_BuildProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
}
